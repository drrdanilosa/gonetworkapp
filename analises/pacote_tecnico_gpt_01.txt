√ìtimo! Vou gerar um pacote t√©cnico com todos os c√≥digos, estruturas de diret√≥rios, stores Zustand, componentes React e rotas API para implementar automa√ß√µes de workflow e funcionalidades de intera√ß√£o entre cliente e editor dentro do padr√£o j√° usado no reposit√≥rio `contatogonetwork/melhorapp_final`.

As implementa√ß√µes ser√£o organizadas para funcionar em Next.js 15 com Zustand e o padr√£o de arquitetura modular por features. Sempre que poss√≠vel, incluirei sugest√µes de melhorias futuras com tecnologias mais robustas, mas implementarei inicialmente com solu√ß√µes simples e diretas para f√°cil aplica√ß√£o no VSCode. Em breve te trago o conte√∫do completo para colar no projeto.


# Implementa√ß√£o de Workflow Autom√°tico e Intera√ß√£o Cliente-Editor

Para implementar as duas funcionalidades propostas sem quebrar a estrutura existente do projeto, siga os passos abaixo. Iremos atualizar os **stores Zustand** para suportar automa√ß√µes de workflow e notifica√ß√µes, criar novos **componentes UI** (Atomic Design) para tarefas, coment√°rios e notifica√ß√µes, e integrar tudo na p√°gina de evento. Cada trecho de c√≥digo inclui coment√°rios indicando sua fun√ß√£o.

## 1. Atualizando os Stores (Zustand)

**a. Store de Projetos (`store/useProjectsStore.ts`):** Vamos estender o store de projetos para incluir **tarefas do projeto** e a√ß√µes autom√°ticas disparadas por eventos. Isso envolve: adicionar a lista de `tasks` em cada projeto, criar tarefas padr√£o na cria√ß√£o de um novo evento, e implementar a√ß√µes como marcar v√≠deo pronto, aprova√ß√£o e solicita√ß√£o de altera√ß√µes. Tamb√©m incluiremos a l√≥gica de marcar coment√°rios como resolvidos. Cole o c√≥digo abaixo em `store/useProjectsStore.ts`, substituindo ou complementando o conte√∫do existente conforme necess√°rio:

```typescript
// store/useProjectsStore.ts
import { create } from 'zustand';
import { useUIStore } from '@/store/useUIStore';  // Importa o store de UI para disparar notifica√ß√µes

// Defini√ß√£o de tipos para tarefas, coment√°rios, entregas (v√≠deos) e projetos
type TaskStatus = 'pending' | 'completed';
interface Task {
  id: string;
  title: string;
  status: TaskStatus;
}
interface Comment {
  id: string;
  authorId: string;
  authorName: string;
  text: string;
  timestamp: number;
  resolved: boolean;
}
type DeliverableStatus = 'editing' | 'ready_for_review' | 'changes_requested' | 'approved';
interface Deliverable {
  id: string;
  title: string;
  url?: string;
  status: DeliverableStatus;
  comments: Comment[];
}
interface Project {
  id: string;
  name: string;
  clientId: string;
  deliverables: Deliverable[];
  tasks: Task[];
}

// Fun√ß√£o utilit√°ria para gerar IDs √∫nicos (simples para demo; poder√≠amos usar uuid futuramente)
function generateId(): string {
  return Math.random().toString(36).substr(2, 9);
}

// Tarefas padr√£o para novos projetos/eventos
const defaultTaskTitles: string[] = [
  'Planejamento do projeto',
  'Grava√ß√£o/Produ√ß√£o do v√≠deo',
  'Edi√ß√£o do v√≠deo',
  'Revis√£o do cliente',
  'Aprova√ß√£o final'
];

interface ProjectsState {
  projects: Project[];
  addProject: (projectData: { id?: string; name: string; clientId: string }) => void;
  markVideoReady: (projectId: string, deliverableId: string) => void;
  approveDeliverable: (projectId: string, deliverableId: string) => void;
  requestChanges: (projectId: string, deliverableId: string) => void;
  markCommentResolved: (projectId: string, deliverableId: string, commentId: string) => void;
  toggleTaskCompletion: (projectId: string, taskId: string) => void;
  // ... outras a√ß√µes existentes (ex: addComment, etc.)
}

export const useProjectsStore = create<ProjectsState>((set, get) => ({
  projects: [],
  
  // Adiciona um novo projeto/evento e gera tarefas padr√£o
  addProject: ({ id, name, clientId }) => {
    const projectId = id || generateId();
    // Cria as tarefas padr√£o para o novo projeto
    const tasks: Task[] = defaultTaskTitles.map(title => ({
      id: generateId(),
      title,
      status: 'pending'
    }));
    const newProject: Project = {
      id: projectId,
      name,
      clientId,
      deliverables: [],  // nenhum v√≠deo/entrega inicialmente
      tasks
    };
    set(state => ({
      projects: [...state.projects, newProject]
    }));
  },

  // Editor marca um v√≠deo como "pronto para revis√£o"
  markVideoReady: (projectId, deliverableId) => {
    // Atualiza status do v√≠deo para "ready_for_review", adiciona tarefa de aprova√ß√£o e notifica cliente
    set(state => {
      const projects = state.projects.map(project => {
        if (project.id !== projectId) return project;
        // Atualiza a entrega (v√≠deo) espec√≠fica
        const updatedDeliverables = project.deliverables.map(deliv => {
          if (deliv.id !== deliverableId) return deliv;
          return { ...deliv, status: 'ready_for_review' };
        });
        // Adiciona a tarefa "Aguardando aprova√ß√£o do v√≠deo" se ainda n√£o existir
        let updatedTasks = project.tasks;
        const approvalTaskExists = project.tasks.some(task => task.title.includes('Aprova√ß√£o') && task.status === 'pending');
        if (!approvalTaskExists) {
          updatedTasks = [
            ...project.tasks,
            { id: generateId(), title: 'Aguardando aprova√ß√£o do v√≠deo', status: 'pending' }
          ];
        }
        return { ...project, deliverables: updatedDeliverables, tasks: updatedTasks };
      });
      return { projects };
    });
    // Dispara notifica√ß√£o na UI (toast) informando que o v√≠deo foi enviado para revis√£o
    useUIStore.getState().addNotification('V√≠deo marcado como pronto para revis√£o.');
    // TODO: Em um cen√°rio real, aqui entrar√≠amos em contato com o backend/WebSocket para notificar o cliente do projeto
  },

  // Cliente aprova o v√≠deo entregue
  approveDeliverable: (projectId, deliverableId) => {
    set(state => {
      const projects = state.projects.map(project => {
        if (project.id !== projectId) return project;
        // Atualiza status do v√≠deo para "approved"
        const updatedDeliverables = project.deliverables.map(deliv => {
          if (deliv.id !== deliverableId) return deliv;
          return { ...deliv, status: 'approved' };
        });
        // Marca a tarefa de aprova√ß√£o como conclu√≠da
        const updatedTasks = project.tasks.map(task => {
          if (task.title.includes('Aguardando aprova√ß√£o') && task.status === 'pending') {
            return { ...task, status: 'completed' };
          }
          return task;
        });
        return { ...project, deliverables: updatedDeliverables, tasks: updatedTasks };
      });
      return { projects };
    });
    // Notifica o cliente (usu√°rio atual) que a aprova√ß√£o foi registrada
    useUIStore.getState().addNotification('Entrega aprovada com sucesso!');
    // TODO: Notificar o editor via WebSocket que o v√≠deo foi aprovado (em uma aplica√ß√£o real)
  },

  // Cliente solicita altera√ß√µes no v√≠deo
  requestChanges: (projectId, deliverableId) => {
    set(state => {
      const projects = state.projects.map(project => {
        if (project.id !== projectId) return project;
        // Atualiza status do v√≠deo para "changes_requested"
        const updatedDeliverables = project.deliverables.map(deliv => {
          if (deliv.id !== deliverableId) return deliv;
          return { ...deliv, status: 'changes_requested' };
        });
        // Adiciona tarefa de "Implementar altera√ß√µes solicitadas"
        const updatedTasks = [
          ...project.tasks,
          { id: generateId(), title: 'Implementar altera√ß√µes solicitadas', status: 'pending' }
        ];
        return { ...project, deliverables: updatedDeliverables, tasks: updatedTasks };
      });
      return { projects };
    });
    // Notifica o cliente (usu√°rio atual) que a solicita√ß√£o foi enviada
    useUIStore.getState().addNotification('Solicita√ß√£o de altera√ß√µes registrada.');
    // TODO: Notificar o editor via WebSocket que foram solicitadas altera√ß√µes
  },

  // Editor marca um coment√°rio como resolvido
  markCommentResolved: (projectId, deliverableId, commentId) => {
    set(state => {
      const projects = state.projects.map(project => {
        if (project.id !== projectId) return project;
        const updatedDeliverables = project.deliverables.map(deliv => {
          if (deliv.id !== deliverableId) return deliv;
          const updatedComments = deliv.comments.map(comment => {
            if (comment.id === commentId) {
              return { ...comment, resolved: true };
            }
            return comment;
          });
          return { ...deliv, comments: updatedComments };
        });
        return { ...project, deliverables: updatedDeliverables };
      });
      return { projects };
    });
  },

  // Alterna status de uma tarefa (para a equipe marcar como conclu√≠da/n√£o conclu√≠da)
  toggleTaskCompletion: (projectId, taskId) => {
    set(state => {
      const projects = state.projects.map(project => {
        if (project.id !== projectId) return project;
        const updatedTasks = project.tasks.map(task => {
          if (task.id === taskId) {
            const newStatus: TaskStatus = task.status === 'pending' ? 'completed' : 'pending';
            return { ...task, status: newStatus };
          }
          return task;
        });
        return { ...project, tasks: updatedTasks };
      });
      return { projects };
    });
  }

  // ... (demais a√ß√µes ou estados do store de projetos)
}));
```

No c√≥digo acima, adicionamos a propriedade `tasks` ao projeto, definimos tarefas padr√£o (planejamento, grava√ß√£o, edi√ß√£o, revis√£o, aprova√ß√£o) ao criar um novo evento (`addProject`), e criamos a√ß√µes autom√°ticas:

* `markVideoReady`: Quando o editor marca um v√≠deo como pronto para revis√£o, o estado da entrega muda para `ready_for_review`, √© criada automaticamente uma tarefa **"Aguardando aprova√ß√£o do v√≠deo"** (caso ainda n√£o exista) e uma notifica√ß√£o √© disparada (usando o store de UI, que configuraremos a seguir). Em uma aplica√ß√£o real, aqui tamb√©m notificar√≠amos o cliente via backend (por ex., enviando um evento em tempo real por WebSocket ou e-mail).

* `approveDeliverable`: Quando o cliente aprova a entrega, marcamos o status do v√≠deo como `approved`, atualizamos a tarefa de aprova√ß√£o para **conclu√≠da** (`completed`) e mostramos uma notifica√ß√£o de sucesso para o cliente. (Num cen√°rio real, tamb√©m avisar√≠amos o editor via WebSocket de que o v√≠deo foi aprovado).

* `requestChanges`: Quando o cliente solicita mudan√ßas, o status do v√≠deo passa para `changes_requested` e √© criada uma tarefa **"Implementar altera√ß√µes solicitadas"** para a equipe de edi√ß√£o. Tamb√©m mantemos a tarefa de aprova√ß√£o pendente, indicando que haver√° nova rodada de aprova√ß√£o. Uma notifica√ß√£o √© exibida confirmando ao cliente que o pedido foi registrado. (Novamente, numa implementa√ß√£o real, o editor seria notificado em tempo real do pedido de altera√ß√µes).

* `markCommentResolved`: Marca um coment√°rio (feedback do cliente) como **resolvido**. Somente editores devem usar essa a√ß√£o, ao corrigir um ponto levantado pelo cliente. O coment√°rio recebe `resolved: true` no estado.

* `toggleTaskCompletion`: Permite alternar o status de uma tarefa qualquer entre pendente e conclu√≠da. Isso ser√° usado principalmente pela equipe interna para marcar tarefas internas (ex.: "Edi√ß√£o do v√≠deo") como feitas. Observa√ß√£o: tarefas de aprova√ß√£o do cliente n√£o devem ser marcadas manualmente pela equipe ‚Äì vamos tratar disso na interface.

> **Nota:** As chamadas `useUIStore.getState().addNotification(...)` integram o store de UI para exibir notifica√ß√µes no front-end. Iremos configurar `useUIStore` no pr√≥ximo passo. Os coment√°rios `// TODO` indicam pontos de poss√≠vel evolu√ß√£o futura, como integra√ß√£o com notifica√ß√µes em tempo real via WebSockets ou backend (sem adicionar depend√™ncias externas agora, mas planejando a evolu√ß√£o).

**b. Store de UI (`store/useUIStore.ts`):** Agora adicionaremos um sistema simples de **notifica√ß√µes internas** usando Zustand. Este store manter√° uma lista de notifica√ß√µes e fun√ß√µes para adicionar e remover notifica√ß√µes. Usaremos isso para mostrar toasts de aviso/a√ß√£o para usu√°rios (tanto editores quanto clientes, conforme o caso). Cole o c√≥digo abaixo em `store/useUIStore.ts` (adapte para mesclar com conte√∫do existente do UI store, se houver):

```typescript
// store/useUIStore.ts
import { create } from 'zustand';

interface Notification {
  id: string;
  message: string;
  // Futuramente, poder√≠amos incluir tipo (info, erro, etc.) e outros metadados
}

interface UIState {
  notifications: Notification[];
  addNotification: (message: string) => void;
  removeNotification: (id: string) => void;
  // ... outras propriedades de UI (ex: estado de modal, tema, etc.)
}

// Gera ID √∫nico simples para notifica√ß√µes (poderia usar uuid no futuro)
function generateId(): string {
  return Math.random().toString(36).substr(2, 9);
}

export const useUIStore = create<UIState>((set, get) => ({
  notifications: [],

  addNotification: (message) => {
    const id = generateId();
    set(state => ({
      notifications: [...state.notifications, { id, message }]
    }));
    // Remove automaticamente a notifica√ß√£o ap√≥s 5 segundos
    const removeFn = get().removeNotification;
    setTimeout(() => {
      removeFn(id);
    }, 5000);
  },

  removeNotification: (id) => {
    set(state => ({
      notifications: state.notifications.filter(n => n.id !== id)
    }));
  }

  // ... (outras propriedades/a√ß√µes de UI j√° existentes)
}));
```

No c√≥digo acima, `notifications` √© um array global de notifica√ß√µes ativas. Ao chamar `addNotification("Texto da mensagem")`, uma nova notifica√ß√£o √© adicionada com um `id` √∫nico e removida automaticamente ap√≥s 5 segundos (usando `setTimeout`). A fun√ß√£o `removeNotification` permite remover manualmente uma notifica√ß√£o antes do tempo (√∫til para um bot√£o de fechar, por exemplo). Mantivemos tudo simples, sem depend√™ncias adicionais.

> **Dica:** No futuro, voc√™ pode trocar este sistema simples por uma biblioteca de toasts mais robusta (como o **react-hot-toast** ou integrar o componente de Toast do shadcn/UI), mas nosso c√≥digo acima cumpre o b√°sico sem adicionar depend√™ncias externas agora.

## 2. Criando os Componentes de Interface (Atomic Design)

Agora vamos criar os componentes necess√°rios na interface, seguindo a organiza√ß√£o modular do projeto (`components/widgets`, `components/video`, etc.). Esses componentes usar√£o os stores que definimos para ler o estado e disparar a√ß√µes. Lembre-se de incluir `**"use client"**` no topo de cada componente interativo, j√° que estamos no ambiente Next.js App Router.

**a. Lista de Tarefas do Projeto (`components/widgets/TaskList.tsx`):** Este componente exibir√° as tarefas do projeto/evento em forma de checklist. Cada tarefa conclu√≠da ser√° mostrada riscada, e as caixas de sele√ß√£o permitir√£o marcar como conclu√≠do ou n√£o. Somente membros da equipe (editores) poder√£o interagir marcando tarefas; para clientes, ou para tarefas de aprova√ß√£o do cliente, os checkboxes ficam desabilitados (evitando que a equipe marque aprova√ß√µes como feitas manualmente). Crie o arquivo e cole o c√≥digo:

```tsx
// components/widgets/TaskList.tsx
"use client";

import { useAuthStore } from '@/store/useAuthStore';
import { useProjectsStore } from '@/store/useProjectsStore';

interface TaskListProps {
  projectId: string;
}

export function TaskList({ projectId }: TaskListProps) {
  // Obtemos as tarefas do projeto atual do store
  const tasks = useProjectsStore(state => {
    const project = state.projects.find(p => p.id === projectId);
    return project ? project.tasks : [];
  });
  const toggleTaskCompletion = useProjectsStore(state => state.toggleTaskCompletion);
  const currentUserRole = useAuthStore(state => state.user?.role);

  return (
    <div className="bg-white shadow rounded p-4 mb-4">
      <h3 className="font-semibold mb-2">Tarefas do Projeto</h3>
      <ul className="space-y-1">
        {tasks.map(task => (
          <li key={task.id} className="flex items-center">
            <input
              type="checkbox"
              className="mr-2"
              checked={task.status === 'completed'}
              onChange={() => toggleTaskCompletion(projectId, task.id)}
              disabled={currentUserRole !== 'editor' || task.title.toLowerCase().includes('aprova√ß√£o')}
            />
            <span className={task.status === 'completed' ? 'line-through text-gray-500' : ''}>
              {task.title}
            </span>
            {task.status === 'completed' && (
              <span className="ml-2 text-green-600 text-sm">[Conclu√≠da]</span>
            )}
          </li>
        ))}
      </ul>
    </div>
  );
}
```

Explica√ß√£o: o componente busca as tarefas do projeto pelo `projectId` (via Zustand). Para cada tarefa, exibimos uma linha com um checkbox e o t√≠tulo. Se a tarefa est√° marcada como `completed`, estilizamos o texto riscado e adicionamos a tag "\[Conclu√≠da]". A propriedade `disabled` do checkbox fica verdadeira se o usu√°rio atual **n√£o** for editor ou se a tarefa tiver "aprova√ß√£o" no t√≠tulo ‚Äì isso impede que clientes alterem tarefas (eles ver√£o apenas o progresso) e que a equipe marque tarefas de aprova√ß√£o de cliente manualmente. A fun√ß√£o `toggleTaskCompletion` √© chamada quando um editor marca/desmarca uma tarefa pendente (por exemplo, ap√≥s terminar a edi√ß√£o do v√≠deo, o editor pode marcar a tarefa "Edi√ß√£o do v√≠deo" como conclu√≠da).

**b. Toast de Notifica√ß√µes (`components/widgets/NotificationToast.tsx`):** Este componente exibir√° as notifica√ß√µes ativas em forma de pequenos pop-ups (toasts) no canto da tela. Podemos adicion√°-lo ao layout principal para ficar dispon√≠vel em toda a aplica√ß√£o. Crie o arquivo e cole o c√≥digo:

```tsx
// components/widgets/NotificationToast.tsx
"use client";

import { useUIStore } from '@/store/useUIStore';

export function NotificationToast() {
  const notifications = useUIStore(state => state.notifications);
  const removeNotification = useUIStore(state => state.removeNotification);

  if (notifications.length === 0) return null;  // se n√£o h√° notifica√ß√µes, n√£o renderiza nada

  return (
    <div className="fixed top-4 right-4 space-y-2 z-50">
      {notifications.map(note => (
        <div 
          key={note.id} 
          className="bg-gray-800 text-white px-4 py-3 rounded shadow flex items-center justify-between"
        >
          <span>{note.message}</span>
          <button 
            onClick={() => removeNotification(note.id)} 
            className="ml-4 text-white font-bold"
          >
            x
          </button>
        </div>
      ))}
    </div>
  );
}
```

Explica√ß√£o: o componente observa a lista de `notifications` no `useUIStore`. Cada notifica√ß√£o √© apresentada como uma caixa escura (texto branco) no canto superior direito. O bot√£o "x" permite fechar a notifica√ß√£o antecipadamente (chamando `removeNotification`). Usamos `position: fixed` e um alto √≠ndice Z (`z-50`) para garantir que os toasts flutuem sobre o conte√∫do. As notifica√ß√µes tamb√©m desaparecem automaticamente ap√≥s o tempo configurado no store (5 segundos). Este componente deve ser montado uma vez na aplica√ß√£o (por exemplo, no layout global) para captar todas as notifica√ß√µes disparadas.

**c. Item de Coment√°rio (`components/video/CommentItem.tsx`):** Este componente representa um coment√°rio individual em uma entrega de v√≠deo, mostrando o texto, timestamp e autor, e permitindo marcar como resolvido se o usu√°rio for editor. Crie o arquivo e adicione:

```tsx
// components/video/CommentItem.tsx
"use client";

import { useProjectsStore } from '@/store/useProjectsStore';
import { useAuthStore } from '@/store/useAuthStore';

interface CommentItemProps {
  projectId: string;
  deliverableId: string;
  comment: {
    id: string;
    authorId: string;
    authorName: string;
    text: string;
    timestamp: number;
    resolved: boolean;
  };
}

export function CommentItem({ projectId, deliverableId, comment }: CommentItemProps) {
  const markCommentResolved = useProjectsStore(state => state.markCommentResolved);
  const currentUserRole = useAuthStore(state => state.user?.role);

  // Formata timestamp (segundos) para mm:ss (minutos e segundos)
  const formatTime = (seconds: number) => {
    const m = Math.floor(seconds / 60);
    const s = seconds % 60;
    return \`\${m.toString().padStart(2, '0')}:\${s.toString().padStart(2, '0')}\`;
  };

  return (
    <div className="mb-2 p-2 border-b border-gray-200">
      <div className="text-sm text-gray-600">
        <strong>{comment.authorName}</strong> <span>@ {formatTime(comment.timestamp)}</span>
      </div>
      <div className="text-gray-800">{comment.text}</div>
      <div>
        {comment.resolved ? (
          <span className="text-green-600 text-sm font-medium">Resolvido</span>
        ) : (
          currentUserRole === 'editor' && (
            <button
              onClick={() => markCommentResolved(projectId, deliverableId, comment.id)}
              className="text-blue-600 text-sm underline"
            >
              Marcar como resolvido
            </button>
          )
        )}
      </div>
    </div>
  );
}
```

Explica√ß√£o: cada coment√°rio mostra o nome do autor, o tempo no v√≠deo (`timestamp`) formatado em minutos\:segundos, e o texto. Se o coment√°rio foi marcado como `resolved`, exibimos a etiqueta **"Resolvido"** em verde. Se n√£o foi resolvido e o usu√°rio atual √© um **editor**, exibimos um bot√£o **"Marcar como resolvido"**; ao clicar, ele chama `markCommentResolved` no store, atualizando o status. (Clientes n√£o veem bot√£o, e consideram coment√°rios n√£o resolvidos como pendentes por padr√£o). Assim, os editores podem indicar visualmente que um feedback foi atendido. Os clientes, ao revisar, ver√£o quais coment√°rios j√° foram resolvidos. *(Obs.: Caso seja necess√°rio reabrir um coment√°rio, poder-se-ia implementar um bot√£o "Reabrir" similar, chamando uma a√ß√£o para `resolved: false`. N√£o inclu√≠mos aqui por simplicidade.)*

**d. A√ß√µes da Entrega de V√≠deo (`components/video/DeliverableActions.tsx`):** Este componente renderiza os bot√µes de a√ß√£o e status relacionados a uma entrega de v√≠deo, de acordo com o **papel do usu√°rio** (cliente ou editor) e o **status da entrega**. Isso inclui: bot√£o para editor marcar v√≠deo como pronto para revis√£o, bot√£o de aprova√ß√£o para cliente, bot√£o de solicitar altera√ß√µes para cliente, e indicadores de status (aguardando aprova√ß√£o, aprovado, altera√ß√µes solicitadas, etc.). Crie o arquivo e adicione:

```tsx
// components/video/DeliverableActions.tsx
"use client";

import { useAuthStore } from '@/store/useAuthStore';
import { useProjectsStore } from '@/store/useProjectsStore';

interface DeliverableActionsProps {
  projectId: string;
  deliverable: {
    id: string;
    title: string;
    status: string;
  };
}

export function DeliverableActions({ projectId, deliverable }: DeliverableActionsProps) {
  const currentUserRole = useAuthStore(state => state.user?.role);
  const markVideoReady = useProjectsStore(state => state.markVideoReady);
  const approveDeliverable = useProjectsStore(state => state.approveDeliverable);
  const requestChanges = useProjectsStore(state => state.requestChanges);

  const { status } = deliverable;

  if (currentUserRole === 'editor') {
    // A√ß√µes para o Editor
    if (status === 'editing' || status === 'changes_requested') {
      return (
        <button
          onClick={() => markVideoReady(projectId, deliverable.id)}
          className="px-4 py-2 bg-blue-600 text-white rounded"
        >
          Marcar v√≠deo como pronto para revis√£o
        </button>
      );
    }
    if (status === 'ready_for_review') {
      return <span className="text-orange-600 font-medium">‚è≥ Aguardando aprova√ß√£o do cliente</span>;
    }
    if (status === 'approved') {
      return <span className="text-green-600 font-medium">‚úÖ V√≠deo aprovado pelo cliente</span>;
    }
  }

  if (currentUserRole === 'client') {
    // A√ß√µes para o Cliente
    if (status === 'ready_for_review') {
      return (
        <div>
          <button
            onClick={() => approveDeliverable(projectId, deliverable.id)}
            className="px-4 py-2 mr-2 bg-green-600 text-white rounded"
          >
            Aprovar v√≠deo
          </button>
          <button
            onClick={() => requestChanges(projectId, deliverable.id)}
            className="px-4 py-2 bg-yellow-500 text-white rounded"
          >
            Solicitar altera√ß√µes
          </button>
        </div>
      );
    }
    if (status === 'approved') {
      return <span className="text-green-700 font-medium">‚úÖ Voc√™ j√° aprovou esta entrega</span>;
    }
    if (status === 'changes_requested') {
      return <span className="text-red-600 font-medium">üîÑ Altera√ß√µes solicitadas. Aguardando nova vers√£o.</span>;
    }
    // Se ainda est√° em edi√ß√£o (n√£o enviado para revis√£o)
    if (status === 'editing') {
      return <span className="text-gray-600">‚è≥ O editor est√° trabalhando na entrega...</span>;
    }
  }

  return null;
}
```

Explica√ß√£o: esse componente verifica o `currentUserRole` e o `status` da entrega para decidir o que renderizar:

* **Editor (equipe):**

  * Se o status da entrega √© `"editing"` (v√≠deo em edi√ß√£o) **ou** `"changes_requested"` (cliente pediu altera√ß√µes e o editor est√° ajustando), mostramos o bot√£o **"Marcar v√≠deo como pronto para revis√£o"**. Ao clicar, chama `markVideoReady` no store, disparando a automa√ß√£o de notifica√ß√£o e cria√ß√£o de tarefa de aprova√ß√£o.
  * Se o status √© `"ready_for_review"` (ou seja, o editor j√° marcou como pronto e aguarda resposta), mostramos um r√≥tulo **"‚è≥ Aguardando aprova√ß√£o do cliente"** em laranja, indicando que agora √© com o cliente.
  * Se o status √© `"approved"`, mostramos **"‚úÖ V√≠deo aprovado pelo cliente"** em verde, indicando conclus√£o.
* **Cliente:**

  * Se o status √© `"ready_for_review"` (aguardando a a√ß√£o do cliente), exibimos **dois bot√µes**: **"Aprovar v√≠deo"** (verde) e **"Solicitar altera√ß√µes"** (amarelo). Estes chamam `approveDeliverable` ou `requestChanges` no store, respectivamente. Ao clicar, o status e tarefas ser√£o atualizados automaticamente (conforme a l√≥gica do store), e o cliente ver√° um toast de confirma√ß√£o.
  * Se o status √© `"approved"` (cliente j√° aprovou anteriormente), exibimos **"‚úÖ Voc√™ j√° aprovou esta entrega"** para clareza (e n√£o mostramos bot√µes, j√° que o processo terminou).
  * Se o status √© `"changes_requested"` (cliente j√° pediu altera√ß√µes e est√° aguardando uma nova vers√£o), exibimos **"üîÑ Altera√ß√µes solicitadas. Aguardando nova vers√£o."** em vermelho, informando que a bola est√° com o editor agora.
  * Se o status √© `"editing"` (o v√≠deo ainda nem foi enviado para revis√£o), exibimos **"‚è≥ O editor est√° trabalhando na entrega..."** em cinza, indicando que em breve haver√° algo para revisar.

Dessa forma, cada usu√°rio v√™ apenas os controles pertinentes e informa√ß√µes de status claras. Os bot√µes e textos seguem o padr√£o visual (cores do Tailwind para status diferentes). Sinta-se √† vontade para ajustar o texto/estilos conforme o padr√£o do projeto (por exemplo, usar componentes de UI do shadcn se houver).

## 3. Integrando na P√°gina de Evento e Layout

Com stores e componentes prontos, vamos **integrar tudo na interface existente**:

**a. Layout Global (`app/layout.tsx`):** Importe e renderize o componente `<NotificationToast />` uma vez no layout global, para que as notifica√ß√µes fiquem dispon√≠veis em qualquer p√°gina. Por exemplo:

```tsx
// app/layout.tsx (trecho relevante)
import { NotificationToast } from '@/components/widgets/NotificationToast';

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="pt-BR">
      <head>...</head>
      <body>
        {children}
        <NotificationToast />  {/* Monta o container de toasts no app inteiro */}
      </body>
    </html>
  );
}
```

Isso garantir√° que toda notifica√ß√£o adicionada via `useUIStore` apare√ßa para o usu√°rio, independentemente da p√°gina.

**b. P√°gina de Detalhe do Evento (`app/events/[eventId]/page.tsx`):** Nesta p√°gina, devemos exibir a lista de tarefas, o v√≠deo com coment√°rios e os bot√µes de a√ß√£o configurados acima. Edite a p√°gina conforme o esbo√ßo abaixo, certificando-se de importar os novos componentes (`TaskList`, `DeliverableActions`, `CommentItem`) e usar o `useProjectsStore` para obter o projeto atual:

```tsx
// app/events/[eventId]/page.tsx (exemplo simplificado)
"use client";
import { useProjectsStore } from '@/store/useProjectsStore';
import { TaskList } from '@/components/widgets/TaskList';
import { CommentItem } from '@/components/video/CommentItem';
import { DeliverableActions } from '@/components/video/DeliverableActions';

// ... obter o ID do evento da rota (por exemplo, via props.params) ...
const projectId = params.eventId;

// Buscar projeto no Zustand (alternativamente, poderia vir via React Query)
const project = useProjectsStore(state => state.projects.find(p => p.id === projectId));
if (!project) {
  return <div>Carregando...</div>;
}

// Supondo um v√≠deo/entrega principal por projeto:
const deliverable = project.deliverables[0];

return (
  <div>
    <h1 className="text-xl font-bold mb-4">Evento: {project.name}</h1>

    {/* Lista de tarefas do projeto */}
    <TaskList projectId={projectId} />

    {/* Conte√∫do da entrega de v√≠deo */}
    {deliverable && (
      <div className="mb-8">
        {/* Player de v√≠deo (ou thumbnail) */}
        <video src={deliverable.url} controls className="w-full mb-2" />
        {/* Bot√µes de a√ß√£o da entrega (aprova√ß√£o/altera√ß√µes ou status) */}
        <DeliverableActions projectId={projectId} deliverable={deliverable} />
        
        {/* Se√ß√£o de coment√°rios da entrega */}
        <div className="bg-gray-50 p-4 rounded mt-4">
          <h3 className="font-semibold mb-2">Coment√°rios:</h3>
          {deliverable.comments.map(comment => (
            <CommentItem
              key={comment.id}
              projectId={projectId}
              deliverableId={deliverable.id}
              comment={comment}
            />
          ))}
        </div>
      </div>
    )}
  </div>
);
```

Ajuste o c√≥digo acima conforme a estrutura exata do seu projeto (por exemplo, m√©todos de obten√ß√£o de dados). O importante √© que estamos **inserindo os componentes** criados:

* `<TaskList projectId={...} />` ‚Äì lista as tarefas padr√£o e atualizadas do projeto.
* `<DeliverableActions ... />` ‚Äì mostra os bot√µes ou status referentes √† entrega, de acordo com o usu√°rio.
* Mapeamento de coment√°rios do `deliverable` para `<CommentItem ... />` ‚Äì lista os coment√°rios com op√ß√£o de resolu√ß√£o.
* O `<NotificationToast />` j√° foi inclu√≠do no layout global, ent√£o n√£o √© necess√°rio adicion√°-lo aqui na p√°gina (evite duplica√ß√£o).

**c. Fluxo de Cria√ß√£o de Evento:** Quando um novo evento/projeto for criado (por exemplo, via um formul√°rio em alguma p√°gina de cria√ß√£o), utilize o m√©todo `addProject` do `useProjectsStore` para adicion√°-lo localmente com as tarefas padr√£o. Supondo que voc√™ tenha um formul√°rio que chama uma API para criar o evento no backend, no retorno voc√™ pode fazer:

```tsx
useProjectsStore.getState().addProject({ id: criado.id, name: criado.nome, clientId: criado.clienteId });
```

Isso garante que imediatamente ap√≥s criar um evento, o estado cliente j√° contenha as tarefas padr√£o daquele projeto. Caso esteja usando React Query para listar projetos, outra abordagem √© revalidar a lista ap√≥s cria√ß√£o ‚Äì contanto que o backend envie tamb√©m as tarefas padr√£o, ou voc√™ pode inserir manualmente no cache. Em nosso caso, estamos focando na atualiza√ß√£o do estado cliente para efeito imediato.

## 4. Testando as Novas Funcionalidades

Ap√≥s colar e ajustar todos os c√≥digos acima no seu projeto, rode o aplicativo (`npm run dev`) e verifique os seguintes cen√°rios para garantir que tudo est√° funcionando:

1. **Novo Evento com Tarefas Padr√£o:** Crie um novo evento/projeto (por exemplo, "Evento X"). Ao ser criado, v√° para a p√°gina do evento e confirme que a se√ß√£o "Tarefas do Projeto" exibe as tarefas padr√£o (Planejamento, Grava√ß√£o, Edi√ß√£o, etc.) marcadas como pendentes. Isso indica que o `addProject` funcionou e populou as tarefas corretamente.

2. **Fluxo Editor -> Cliente (Revis√£o):** Fa√ßa login como **editor** e adicione uma entrega (v√≠deo) ao evento. Uma vez pronto, clique no bot√£o **"Marcar v√≠deo como pronto para revis√£o"**. Isso deve:

   * Mudar o status da entrega para *ready\_for\_review* internamente.
   * Adicionar automaticamente a tarefa "**Aguardando aprova√ß√£o do v√≠deo**" na lista de tarefas do projeto.
   * Exibir um toast de notifica√ß√£o no canto superior direito confirmando que o v√≠deo foi enviado para revis√£o.
   * (No mundo real, enviaria notifica√ß√£o ao cliente; aqui vemos a indica√ß√£o localmente.)

3. **Fluxo Cliente (Aprova√ß√£o):** Fa√ßa login como **cliente** que possui acesso a esse evento (ou alternativamente, mude temporariamente o `currentUserRole` para 'client' no estado para simular). Ao abrir a p√°gina do evento:

   * Voc√™ deve ver o bot√£o **"Aprovar v√≠deo"** e **"Solicitar altera√ß√µes"** porque o status est√° "pronto para revis√£o".
   * Clique em **"Aprovar v√≠deo"**. Isso deve marcar a tarefa de aprova√ß√£o como conclu√≠da (veja a TaskList ‚Äì "Aguardando aprova√ß√£o do v√≠deo" ficar√° riscada como *\[Conclu√≠da]*), alterar o status da entrega para *approved*, remover os bot√µes de a√ß√£o e em vez disso mostrar "‚úÖ Voc√™ j√° aprovou esta entrega". Um toast de "Entrega aprovada com sucesso!" ser√° exibido para confirmar sua a√ß√£o.
   * (Novamente, em cen√°rio real o editor receberia uma notifica√ß√£o de aprova√ß√£o; aqui focamos no lado do cliente.)

4. **Fluxo Cliente (Solicitar Altera√ß√µes):** Alternativamente, em vez de aprovar, teste o bot√£o **"Solicitar altera√ß√µes"**:

   * Ao clicar, o status da entrega deve mudar para *changes\_requested*. Os bot√µes somem e voc√™ ver√° "üîÑ Altera√ß√µes solicitadas. Aguardando nova vers√£o." indicando que o cliente est√° aguardando.
   * Na TaskList, uma nova tarefa "**Implementar altera√ß√µes solicitadas**" ser√° adicionada automaticamente para a equipe, enquanto a tarefa de "Aguardando aprova√ß√£o do v√≠deo" permanece pendente (pois haver√° outra rodada de aprova√ß√£o depois).
   * Um toast "Solicita√ß√£o de altera√ß√µes registrada." aparece para o cliente. (Em uso real, o editor seria alertado do pedido de altera√ß√µes.)
   * Se voc√™ agora fizer login como editor e visitar o evento, ver√° o status *changes\_requested* e o bot√£o "Marcar v√≠deo como pronto..." novamente dispon√≠vel (para enviar a nova vers√£o). As tarefas indicar√£o que h√° uma pendente de implementar altera√ß√µes. Uma vez que o editor fizer os ajustes e clique novamente em "Marcar pronto para revis√£o", voc√™ poderia repetir o ciclo de aprova√ß√£o.

5. **Coment√°rios com Resolu√ß√£o:** Adicione coment√°rios como cliente (o projeto j√° suporta coment√°rios com timestamp). Depois, ao logar como editor e visualizar os coment√°rios listados, clique em **"Marcar como resolvido"** em alguns deles. Verifique que:

   * O texto "Resolvido" aparece ao lado do coment√°rio, em verde, e o bot√£o some (pois j√° est√° resolvido).
   * Se fizer login novamente como cliente, aqueles coment√°rios marcados como resolvidos aparecem com a etiqueta "Resolvido", indicando que o editor j√° cuidou daqueles pontos.

6. **Notifica√ß√µes Internas:** Teste cen√°rios de notifica√ß√µes:

   * Toda vez que voc√™ executa uma dessas a√ß√µes (marcar v√≠deo pronto, aprovar, pedir altera√ß√£o), um toast deve aparecer no canto. Tente n√£o clicar para que ele desapare√ßa sozinho ap√≥s alguns segundos, e tente clicar no "x" para fechar imediatamente ‚Äì ambos devem remover a notifica√ß√£o.
   * As notifica√ß√µes devem respeitar o estilo e n√£o acumular indefinidamente (cada uma sai ap√≥s 5s). Voc√™ pode gerar notifica√ß√µes de teste chamando `useUIStore.getState().addNotification("Mensagem")` no console do navegador para ver o comportamento.

Se todos os passos acima funcionarem como descrito, voc√™ ter√° integrado com sucesso as **automa√ß√µes de workflow** e as **funcionalidades de intera√ß√£o cliente-editor** no projeto **MelhorApp**, mantendo o padr√£o visual e estrutural existente. üéâ

Cada parte do c√≥digo √© modular e isolada, seguindo a arquitetura de features (usamos `store/` para estado global, `components/widgets` e `components/video` para UI, etc.). Voc√™ pode evoluir essas implementa√ß√µes futuramente, por exemplo:

* Refinar o sistema de notifica√ß√µes para usar WebSockets reais e notificar usu√°rios espec√≠ficos em tempo real.
* Persistir o status de tarefas e coment√°rios no backend, sincronizando com a interface (as estruturas est√£o prontas para isso).
* Adicionar feedback visual mais rico (por exemplo, usar √≠cones do shadcn/UI nos bot√µes, anima√ß√µes nos toasts, etc.).

Integrado o pacote de c√≥digos acima, o aplicativo dever√° oferecer uma experi√™ncia aprimorada, automatizando tarefas repetitivas (workflow) e melhorando a comunica√ß√£o entre clientes e editores. Boa codifica√ß√£o! üöÄ
