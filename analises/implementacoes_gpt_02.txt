Perfeito! Vou desenvolver os c√≥digos e orienta√ß√µes completos para implementar as seguintes funcionalidades, seguindo sua ordem de prioridade e a arquitetura atual do MelhorApp:

1. Integra√ß√£o de IA para gerar sugest√µes autom√°ticas com base no briefing
2. Comunica√ß√£o em tempo real via chat ou coment√°rios sincronizados
3. Aprova√ß√£o com assinatura digital do cliente
4. Biblioteca inteligente de assets com busca e tagging
5. Relat√≥rios de performance por evento com dashboards visuais

Todos os c√≥digos ser√£o preparados em TypeScript/Next.js 15 com Zustand e a arquitetura modular baseada em features, respeitando o padr√£o visual e estrutural atual do reposit√≥rio. Apresentarei os c√≥digos prontos para colar no VSCode, com indica√ß√µes para melhorias futuras.

Em breve, trago o primeiro bloco com a integra√ß√£o de IA para sugest√µes baseadas no briefing.


# Implementa√ß√£o das Funcionalidades Solicitadas no MelhorApp

A seguir apresentamos cada funcionalidade pedida, em ordem de prioridade, com c√≥digo completo (stores Zustand, componentes React e rotas API) e instru√ß√µes de integra√ß√£o e teste. Todo o c√≥digo est√° em TypeScript e segue a estrutura modular do projeto **MelhorApp** (Next.js App Router, Zustand, Tailwind/Dracula Theme). Coment√°rios no c√≥digo indicam melhorias futuras (ex.: integra√ß√£o com APIs externas) e depend√™ncias opcionais.

## 1. Integra√ß√£o de IA para Sugest√µes Autom√°ticas (Briefing)

Esta funcionalidade gera sugest√µes autom√°ticas de roteiro, estrutura de v√≠deo e tags com base no conte√∫do do briefing preenchido pelo cliente. Inclu√≠mos um **store Zustand** para gerenciar o estado de sugest√£o, um **componente de UI** com bot√£o e √°rea de sugest√µes, e uma **rota API** local para gerar sugest√µes (simulada). Futuramente, essa rota pode ser substitu√≠da por integra√ß√£o com a API do OpenAI (indicamos isso nos coment√°rios).

### Store: `store/useSuggestionStore.ts`

Gerencia o estado das sugest√µes (carregamento, resultado ou erro) e exp√µe a a√ß√£o `generateSuggestions` que chama a API local `/api/suggestions`. Certifique-se de importar este store apenas em componentes client-side.

```tsx
// store/useSuggestionStore.ts
import { create } from 'zustand';

interface SuggestionsResult {
  script: string;
  structure: string;
  tags: string[];
}

interface SuggestionState {
  loading: boolean;
  suggestions: SuggestionsResult | null;
  error: string | null;
  generateSuggestions: (briefingText: string) => Promise<void>;
}

export const useSuggestionStore = create<SuggestionState>((set) => ({
  loading: false,
  suggestions: null,
  error: null,
  // A√ß√£o para gerar sugest√µes chamando a API local
  generateSuggestions: async (briefingText) => {
    set({ loading: true, error: null });
    try {
      const res = await fetch('/api/suggestions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ briefing: briefingText })
      });
      if (!res.ok) {
        throw new Error(`Erro ${res.status} ao gerar sugest√µes`);
      }
      const data: SuggestionsResult = await res.json();
      set({ suggestions: data });
    } catch (err: any) {
      console.error('Erro ao obter sugest√µes:', err);
      set({ error: err.message || 'Falha ao gerar sugest√µes' });
    } finally {
      set({ loading: false });
    }
  }
}));
```

### Componente: `components/widgets/BriefingSuggestions.tsx`

Componente React client-side que exibe um bot√£o "Gerar Sugest√µes" e, quando clicado, usa o store acima para solicitar sugest√µes. Mostra um indicador de *loading* enquanto aguarda a resposta e ent√£o exibe as sugest√µes de roteiro, estrutura e tags geradas. Deve ser inserido na p√°gina do formul√°rio de briefing (por exemplo, ap√≥s o textarea ou campos de briefing).

```tsx
// components/widgets/BriefingSuggestions.tsx
'use client';
import { useState } from 'react';
import { useSuggestionStore } from '@/store/useSuggestionStore';

interface BriefingSuggestionsProps {
  briefingText: string;
}

export default function BriefingSuggestions({ briefingText }: BriefingSuggestionsProps) {
  const { loading, suggestions, error, generateSuggestions } = useSuggestionStore();
  const [hasRequested, setHasRequested] = useState(false);

  const handleGenerate = async () => {
    if (!briefingText || briefingText.trim().length === 0) return;
    setHasRequested(true);
    await generateSuggestions(briefingText);
  };

  return (
    <div className="mt-4 p-4 rounded bg-neutral-800 text-neutral-100">
      <button
        onClick={handleGenerate}
        disabled={loading || !briefingText}
        className="px-4 py-2 mb-3 rounded bg-purple-600 hover:bg-purple-700 disabled:bg-gray-600"
      >
        {loading ? 'Gerando sugest√µes...' : 'Gerar Sugest√µes'}
      </button>
      {/* √Årea de sugest√µes ou mensagens de erro */}
      {error && (
        <p className="text-red-400">Erro: {error}</p>
      )}
      {!error && suggestions && hasRequested && !loading && (
        <div className="mt-2">
          <h4 className="font-bold">Sugest√£o de Roteiro:</h4>
          <p className="mb-2 whitespace-pre-line">{suggestions.script}</p>
          <h4 className="font-bold">Sugest√£o de Estrutura:</h4>
          <p className="mb-2 whitespace-pre-line">{suggestions.structure}</p>
          <h4 className="font-bold">Tags Recomendadas:</h4>
          <div className="flex flex-wrap gap-2">
            {suggestions.tags.map((tag, idx) => (
              <span key={idx} className="px-2 py-1 text-sm bg-teal-700 rounded">
                {tag}
              </span>
            ))}
          </div>
        </div>
      )}
      {/* Fallback quando ainda n√£o foi solicitado */}
      {!error && !suggestions && !loading && !hasRequested && (
        <p className="text-sm text-neutral-400">Preencha o briefing e clique em "Gerar Sugest√µes" para dicas autom√°ticas.</p>
      )}
    </div>
  );
}
```

### Rota API: `app/api/suggestions/route.ts`

Endpoint API (Next.js App Router) que recebe o briefing e retorna sugest√µes simuladas. No futuro, essa l√≥gica pode ser aprimorada com IA real (por exemplo, chamando a API da OpenAI com o conte√∫do do briefing). Por ora, usamos uma simula√ß√£o simples: geramos um texto de roteiro e estrutura gen√©rico e extra√≠mos palavras-chave do briefing para sugerir tags.

```ts
// app/api/suggestions/route.ts
import { NextRequest, NextResponse } from 'next/server';

export async function POST(request: NextRequest) {
  const { briefing } = await request.json();
  if (!briefing || briefing.trim().length === 0) {
    return NextResponse.json({ error: 'Briefing vazio' }, { status: 400 });
  }
  // L√≥gica simulada para gerar sugest√µes. (Melhoria futura: integrar com OpenAI API)
  const scriptSugestao = `Com base no briefing fornecido, uma ideia de roteiro seria come√ßar apresentando: "${briefing.slice(0, 60)}..." e ent√£o desenvolver os pontos principais, concluindo com uma chamada √† a√ß√£o.`;
  const estruturaSugestao = 'Estrutura sugerida: Introdu√ß√£o, Desenvolvimento dos t√≥picos centrais em segmentos claros, e Conclus√£o refor√ßando a mensagem final.';
  // Gerar tags simples a partir das palavras do briefing (pega 3 primeiras palavras significativas como exemplo)
  const palavras = briefing.split(/\s+/).filter((w: string) => w.length > 3);
  const tagsSugestao = palavras.slice(0, 3).map((w: string) => w.replace(/[^a-zA-Z0-9]/g, '').toLowerCase());
  return NextResponse.json({
    script: scriptSugestao,
    structure: estruturaSugestao,
    tags: tagsSugestao.length ? tagsSugestao : ['video', 'ideia', 'produ√ß√£o']
  });
}
```

**Integra√ß√£o e Teste:** Para integrar esta funcionalidade:

1. Inclua o componente **`<BriefingSuggestions />`** na p√°gina de briefing do evento (por exemplo, em `app/events/[eventId]/briefing/page.tsx` ou logo ap√≥s o formul√°rio de briefing), passando o texto do briefing como propriedade conforme o exemplo abaixo.
2. Preencha o briefing e clique em **"Gerar Sugest√µes"**. Verifique se aparece a mensagem de carregamento e, em seguida, as sugest√µes geradas (roteiro, estrutura e tags) s√£o exibidas.
3. Teste tamb√©m o caso de erro: deixe o briefing vazio e clique no bot√£o para confirmar que uma mensagem de erro √© mostrada.

```tsx
// Exemplo de uso na p√°gina de Briefing (trecho simplificado)
import BriefingSuggestions from '@/components/widgets/BriefingSuggestions';
...
const [briefingText, setBriefingText] = useState('');
return (
  <form>
    <textarea value={briefingText} onChange={(e) => setBriefingText(e.target.value)} ... />
    {/* Bot√£o e sugest√µes */}
    <BriefingSuggestions briefingText={briefingText} />
  </form>
);
```

## 2. Comunica√ß√£o em Tempo Real via Chat/Coment√°rios

Esta funcionalidade adiciona um chat em tempo real por evento, permitindo comunica√ß√£o direta entre o **cliente** e o **editor**, al√©m de sincronizar coment√°rios no v√≠deo. Implementamos um **store de colabora√ß√£o** (Zustand) que gerencia mensagens, presen√ßa de usu√°rios e indica√ß√£o de digita√ß√£o (*"typing"*), e um **componente de chat** que exibe as mensagens e permite envio em tempo real.

> **Nota:** Aqui utilizamos uma simula√ß√£o local de "tempo real". Para uma solu√ß√£o em produ√ß√£o, recomenda-se integrar um WebSocket real (por exemplo, usando **Socket.IO** ou **Web APIs** nativas) ou servi√ßos de terceiros (Pusher, Firebase) para sincronizar mensagens entre diferentes clientes. Indicamos nos coment√°rios onde essa evolu√ß√£o pode ser feita.

### Store: `store/useCollaborationStore.ts`

Este store, extens√≠vel do existente `useCollaborationStore`, gerencia o estado de colabora√ß√£o em tempo real: mant√©m as mensagens do chat, status online de cada parte (cliente/editor) e quem est√° digitando no momento. A a√ß√£o `sendMessage` adiciona uma mensagem e simula o recebimento pela outra parte ap√≥s um breve intervalo (para demonstrar a intera√ß√£o).

```tsx
// store/useCollaborationStore.ts (extens√£o ou inclus√£o de funcionalidades de chat)
import { create } from 'zustand';

interface ChatMessage {
  id: string;
  sender: 'editor' | 'client';
  text: string;
  timestamp: number;
}
interface CollaborationState {
  messages: ChatMessage[];
  clientOnline: boolean;
  editorOnline: boolean;
  clientTyping: boolean;
  editorTyping: boolean;
  sendMessage: (sender: 'editor' | 'client', text: string) => void;
  setTyping: (sender: 'editor' | 'client', isTyping: boolean) => void;
  connectUser: (user: 'editor' | 'client') => void;
  disconnectUser: (user: 'editor' | 'client') => void;
}

export const useCollaborationStore = create<CollaborationState>((set, get) => ({
  messages: [],
  clientOnline: false,
  editorOnline: false,
  clientTyping: false,
  editorTyping: false,
  // Registra usu√°rio como online
  connectUser: (user) => set((state) => (
    user === 'client' ? { clientOnline: true } : { editorOnline: true }
  )),
  // Registra usu√°rio como offline
  disconnectUser: (user) => set((state) => (
    user === 'client' ? { clientOnline: false } : { editorOnline: false }
  )),
  // Atualiza status "digitando" do usu√°rio
  setTyping: (user, isTyping) => set(() => (
    user === 'client' ? { clientTyping: isTyping } : { editorTyping: isTyping }
  )),
  // Envia mensagem e simula resposta do outro lado
  sendMessage: (sender, text) => {
    if (!text.trim()) return;
    const newMsg: ChatMessage = {
      id: Date.now().toString(),
      sender,
      text,
      timestamp: Date.now()
    };
    // Adiciona mensagem enviada
    set((state) => ({ 
      messages: [...state.messages, newMsg],
      // Ao enviar, o usu√°rio atual n√£o est√° mais digitando
      clientTyping: sender === 'client' ? false : state.clientTyping,
      editorTyping: sender === 'editor' ? false : state.editorTyping
    }));
    // Simula√ß√£o: ap√≥s curto intervalo, gerar resposta autom√°tica do outro usu√°rio
    // (Melhoria futura: aqui entraria l√≥gica de WebSocket recebendo mensagem real do outro cliente)
    setTimeout(() => {
      const other: 'editor' | 'client' = sender === 'client' ? 'editor' : 'client';
      // Marca "outro usu√°rio est√° digitando"
      set(() => (other === 'client' ? { clientTyping: true } : { editorTyping: true }));
      setTimeout(() => {
        const reply: ChatMessage = {
          id: (Date.now() + 1).toString(),
          sender: other,
          text: sender === 'client'
            ? 'Mensagem recebida, vou verificar o v√≠deo.'
            : 'Entendi, obrigado pelo feedback!',
          timestamp: Date.now()
        };
        // Adiciona a mensagem de resposta
        set((state) => ({ 
          messages: [...state.messages, reply],
          clientTyping: false,
          editorTyping: false
        }));
      }, 1000); // espera 1s "digitando" antes de enviar
    }, 500);
  }
}));
```

### Componente: `components/widgets/ChatBox.tsx`

Este componente React (client-side) exibe a interface de chat: um hist√≥rico de mensagens, indicadores de usu√°rio online/offline e "digitando...", e um campo de entrada para novas mensagens. Ele utiliza o `useCollaborationStore` para recuperar e atualizar o estado do chat em tempo real. O design utiliza Tailwind para estilizar as mensagens (diferenciando visualmente as do cliente e do editor).

```tsx
// components/widgets/ChatBox.tsx
'use client';
import { useEffect, useRef } from 'react';
import { useCollaborationStore } from '@/store/useCollaborationStore';

interface ChatBoxProps {
  currentUser: 'editor' | 'client';
}

export default function ChatBox({ currentUser }: ChatBoxProps) {
  const inputRef = useRef<HTMLTextAreaElement>(null);
  const {
    messages, clientOnline, editorOnline, clientTyping, editorTyping,
    sendMessage, setTyping, connectUser, disconnectUser
  } = useCollaborationStore();
  const otherUser: 'editor' | 'client' = currentUser === 'client' ? 'editor' : 'client';

  // Mark current user as online when component mounts/unmounts
  useEffect(() => {
    connectUser(currentUser);
    return () => {
      disconnectUser(currentUser);
    };
  }, [currentUser, connectUser, disconnectUser]);

  const handleSend = () => {
    const text = inputRef.current?.value || '';
    if (!text.trim()) return;
    sendMessage(currentUser, text);
    if (inputRef.current) {
      inputRef.current.value = '';
    }
  };
  const handleTyping = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setTyping(currentUser, e.target.value.length > 0);
  };

  return (
    <div className="border border-neutral-700 rounded p-3 max-w-lg flex flex-col bg-neutral-800 text-neutral-100">
      {/* Header com status de usu√°rios */}
      <div className="mb-2 text-sm text-neutral-400">
        <span className={`mr-4 ${clientOnline ? 'text-green-400' : 'text-neutral-500'}`}>
          üü¢ Cliente {clientOnline ? '(online)' : '(offline)'}
        </span>
        <span className={`${editorOnline ? 'text-green-400' : 'text-neutral-500'}`}>
          üü¢ Editor {editorOnline ? '(online)' : '(offline)'}
        </span>
      </div>
      {/* √Årea de mensagens */}
      <div className="flex-1 overflow-y-auto mb-2 pr-2">
        {messages.map(msg => (
          <div key={msg.id} className={`mb-1 flex ${msg.sender === 'client' ? 'justify-start' : 'justify-end'}`}>
            <div className={`px-2 py-1 rounded text-sm max-w-xs break-words 
              ${msg.sender === 'client' ? 'bg-blue-700 text-white' : 'bg-purple-600 text-white'}`}>
              {msg.text}
            </div>
          </div>
        ))}
        {/* Indicador de "digitando" do outro usu√°rio */}
        { (currentUser === 'client' && editorTyping) && (
          <div className="text-neutral-400 text-xs mb-1">Editor est√° digitando...</div>
        )}
        { (currentUser === 'editor' && clientTyping) && (
          <div className="text-neutral-400 text-xs mb-1">Cliente est√° digitando...</div>
        )}
      </div>
      {/* Input de nova mensagem */}
      <div className="flex items-center">
        <textarea
          ref={inputRef}
          rows={2}
          onChange={handleTyping}
          className="flex-1 text-sm p-2 mr-2 rounded bg-neutral-700 text-white"
          placeholder="Digite uma mensagem..."
        />
        <button onClick={handleSend} className="px-3 py-1 bg-teal-600 rounded hover:bg-teal-700">
          Enviar
        </button>
      </div>
    </div>
  );
}
```

**Integra√ß√£o e Teste:** Para integrar e testar o chat em tempo real:

1. Inclua o componente **`<ChatBox />`** na p√°gina do evento (por exemplo, em `app/events/[eventId]/page.tsx` ou na se√ß√£o de coment√°rios do player de v√≠deo). Passe via props o usu√°rio atual (`'client'` ou `'editor'`, conforme o papel do usu√°rio logado), por exemplo:

   ```tsx
   // Exemplo de integra√ß√£o na p√°gina do evento
   import ChatBox from '@/components/widgets/ChatBox';
   ...
   // Supondo que sabemos o papel do usu√°rio logado (role)
   <ChatBox currentUser={userRole === 'editor' ? 'editor' : 'client'} />
   ```

2. Abra duas janelas do navegador: uma simulando o cliente e outra o editor (ou alternativamente, alterne a prop `currentUser` entre `'client'` e `'editor'` para simular cada lado).

3. Envie mensagens de um lado e observe que elas aparecem na interface (incluindo a resposta autom√°tica simulada do outro usu√°rio).

4. Verifique o indicador de "*digitando...*" quando o outro usu√°rio est√° digitando e o status online/offline (feche uma das janelas para ver o outro usu√°rio ficar *offline*).

5. Lembre-se que esta √© apenas uma simula√ß√£o local. Em um cen√°rio real multiusu√°rio, seria necess√°rio um servidor WebSocket para sincronizar mensagens e remover a l√≥gica de resposta autom√°tica.

## 3. Aprova√ß√£o com Assinatura Digital do Cliente

Nesta funcionalidade, ao **aprovar um v√≠deo** o cliente pode fornecer uma assinatura digital como confirma√ß√£o. Implementamos um **componente de assinatura** que permite desenhar ou digitar o nome como assinatura, e uma **rota API** que registra (simulada) a aprova√ß√£o com assinatura, incluindo IP do cliente, data e hora. Os dados por enquanto s√£o armazenados localmente (em mem√≥ria ou store), mas o c√≥digo est√° preparado para futura persist√™ncia em banco de dados ou armazenamento externo.

### Componente: `components/widgets/SignaturePad.tsx`

Este componente exibe uma pequena √°rea de assinatura onde o cliente pode desenhar sua assinatura com o mouse ou toque, e alternativamente digitar seu nome. Inclui bot√µes para limpar o desenho e confirmar a assinatura. Ao confirmar, ele captura a imagem da assinatura (ou o nome digitado) e chama a callback `onConfirm` fornecida via props, enviando os dados da assinatura.

```tsx
// components/widgets/SignaturePad.tsx
'use client';
import { useRef, useState, useEffect } from 'react';

interface SignaturePadProps {
  onConfirm: (signatureData: { dataUrl?: string; name?: string }) => void;
}

export default function SignaturePad({ onConfirm }: SignaturePadProps) {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [drawing, setDrawing] = useState(false);
  const [typedName, setTypedName] = useState('');

  useEffect(() => {
    const canvas = canvasRef.current;
    if (canvas) {
      // Ajusta resolu√ß√£o do canvas para melhor qualidade
      const ctx = canvas.getContext('2d');
      if (ctx) {
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
    }
  }, []);

  const startDraw = (e: React.PointerEvent<HTMLCanvasElement>) => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 2;
    ctx.beginPath();
    // Pega posi√ß√£o relativa no canvas
    const rect = canvas.getBoundingClientRect();
    ctx.moveTo(e.clientX - rect.left, e.clientY - rect.top);
    setDrawing(true);
  };
  const draw = (e: React.PointerEvent<HTMLCanvasElement>) => {
    if (!drawing) return;
    const canvas = canvasRef.current;
    const ctx = canvas?.getContext('2d');
    if (!ctx) return;
    const rect = canvas.getBoundingClientRect();
    ctx.lineTo(e.clientX - rect.left, e.clientY - rect.top);
    ctx.stroke();
  };
  const endDraw = () => {
    setDrawing(false);
  };
  const clearCanvas = () => {
    const canvas = canvasRef.current;
    const ctx = canvas?.getContext('2d');
    if (ctx && canvas) {
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
  };
  const confirmSignature = () => {
    const canvas = canvasRef.current;
    // Se algo foi desenhado no canvas, usa-o; sen√£o, usa o nome digitado
    if (canvas) {
      const blankCanvas = document.createElement('canvas');
      blankCanvas.width = canvas.width;
      blankCanvas.height = canvas.height;
      const blankCtx = blankCanvas.getContext('2d');
      blankCtx?.fillRect(0, 0, blankCanvas.width, blankCanvas.height);
      const isCanvasBlank = canvas.toDataURL() === blankCanvas.toDataURL();
      if (!isCanvasBlank) {
        const dataUrl = canvas.toDataURL('image/png');
        onConfirm({ dataUrl });
        return;
      }
    }
    // Se canvas estiver em branco ou indispon√≠vel, usa nome digitado
    if (typedName.trim()) {
      onConfirm({ name: typedName.trim() });
    } else {
      alert('Por favor, assine (desenhe ou digite seu nome) antes de confirmar.');
    }
  };

  return (
    <div className="p-4 bg-neutral-800 border border-neutral-600 rounded">
      <h3 className="text-neutral-100 mb-2">Assinatura do Cliente:</h3>
      {/* Canvas para desenhar assinatura */}
      <canvas
        ref={canvasRef}
        width={300}
        height={100}
        className="bg-white mb-2"
        onPointerDown={startDraw}
        onPointerMove={draw}
        onPointerUp={endDraw}
        onPointerLeave={endDraw}
      />
      {/* Input para digitar nome caso prefira */}
      <input
        type="text"
        placeholder="Ou digite seu nome"
        value={typedName}
        onChange={(e) => setTypedName(e.target.value)}
        className="mb-2 w-full px-2 py-1 text-sm bg-neutral-700 text-white rounded"
      />
      {/* Bot√µes de a√ß√µes */}
      <div className="flex justify-between">
        <button type="button" onClick={clearCanvas} className="px-3 py-1 bg-gray-600 rounded hover:bg-gray-500">
          Limpar
        </button>
        <button type="button" onClick={confirmSignature} className="px-3 py-1 bg-teal-600 rounded hover:bg-teal-700">
          Confirmar Assinatura
        </button>
      </div>
    </div>
  );
}
```

### Rota API: `app/api/events/[eventId]/approve/route.ts`

Esta rota recebe os dados da assinatura quando o cliente aprova o v√≠deo. Ela registra (simulado) a aprova√ß√£o, capturando o endere√ßo IP do cliente e timestamp atuais. Sem um banco de dados no momento, os dados podem ser guardados em mem√≥ria ou simplesmente retornados na resposta. Indicamos via coment√°rios onde essa informa√ß√£o poderia ser persistida futuramente.

```ts
// app/api/events/[eventId]/approve/route.ts
import { NextRequest, NextResponse } from 'next/server';

// Estrutura para armazenar aprova√ß√µes em mem√≥ria (simula√ß√£o)
interface ApprovalRecord {
  eventId: string;
  signatureType: 'image' | 'text';
  signatureData: string;
  ip: string;
  timestamp: string;
}
const approvals: ApprovalRecord[] = [];

export async function POST(request: NextRequest, { params }: { params: { eventId: string } }) {
  const { eventId } = params;
  const body = await request.json();
  const { dataUrl, name } = body;
  if (!eventId) {
    return NextResponse.json({ error: 'ID do evento n√£o fornecido' }, { status: 400 });
  }
  // Determina tipo de assinatura e conte√∫do
  let signatureType: 'image' | 'text';
  let signatureData: string;
  if (dataUrl) {
    signatureType = 'image';
    signatureData = dataUrl; // Base64 da imagem da assinatura
  } else if (name) {
    signatureType = 'text';
    signatureData = name;
  } else {
    return NextResponse.json({ error: 'Dados de assinatura ausentes' }, { status: 400 });
  }
  // Captura IP do cliente (pode variar conforme deployment)
  const clientIP = request.headers.get('x-forwarded-for') || request.ip || '0.0.0.0';
  const timestamp = new Date().toISOString();
  // Armazena aprova√ß√£o localmente (simulado; melhoria futura: salvar em banco de dados)
  approvals.push({ eventId, signatureType, signatureData, ip: clientIP, timestamp });
  console.log('Aprova√ß√£o registrada:', approvals[approvals.length - 1]);
  // Retorna confirma√ß√£o com dados relevantes
  return NextResponse.json({
    success: true,
    eventId,
    signatureType,
    ip: clientIP,
    timestamp
  });
}
```

### Uso na P√°gina de Evento (Aprova√ß√£o)

Na p√°gina de detalhes do evento (por exemplo, `app/events/[eventId]/page.tsx` ou similar), voc√™ adicionar√° um bot√£o de "Aprovar" que abre o **SignaturePad** em um modal ou se√ß√£o. Quando o cliente confirma a assinatura, chamamos a rota API para registrar a aprova√ß√£o.

```tsx
// Exemplo de integra√ß√£o na p√°gina de detalhes do evento
import { useState } from 'react';
import SignaturePad from '@/components/widgets/SignaturePad';

export default function EventDetailsPage({ params }: { params: { eventId: string } }) {
  const [showSign, setShowSign] = useState(false);
  const [approved, setApproved] = useState(false);
  const [approvalInfo, setApprovalInfo] = useState<any>(null);
  const eventId = params.eventId;

  const handleApprove = async (signature: { dataUrl?: string; name?: string }) => {
    // Chama API de aprova√ß√£o
    const res = await fetch(`/api/events/${eventId}/approve`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(signature)
    });
    if (res.ok) {
      const data = await res.json();
      setApproved(true);
      setApprovalInfo(data);
    } else {
      alert('Falha ao registrar aprova√ß√£o');
    }
    setShowSign(false);
  };

  return (
    <div>
      {/* ... detalhes do evento e v√≠deo ... */}
      {!approved ? (
        <button onClick={() => setShowSign(true)} className="px-4 py-2 bg-teal-600 rounded">
          Aprovar V√≠deo
        </button>
      ) : (
        <p className="text-green-500">V√≠deo aprovado em {approvalInfo?.timestamp?.substring(0,19).replace('T',' ')} pelo cliente.</p>
      )}
      {showSign && (
        <div className="modal">
          <SignaturePad onConfirm={handleApprove} />
        </div>
      )}
    </div>
  );
}
```

**Teste:** Para testar o fluxo de aprova√ß√£o:

1. No final do fluxo do evento (por exemplo, ap√≥s o editor enviar o v√≠deo final), clique no bot√£o **"Aprovar V√≠deo"**. O componente de assinatura digital (`SignaturePad`) dever√° aparecer (pode ser em um modal).
2. Assine no canvas (desenhando com o mouse ou touch) **ou** digite seu nome no campo fornecido.
3. Clique em **"Confirmar Assinatura"**. Isso enviar√° os dados para a rota API de aprova√ß√£o.
4. Verifique que a interface atualiza para indicar o v√≠deo como aprovado (por exemplo, mostrando a data/hora da aprova√ß√£o e desabilitando o bot√£o de aprovar).
5. Confira no console/terminal do servidor o log impresso com os dados da aprova√ß√£o (incluindo IP, timestamp e tipo de assinatura). *(Em produ√ß√£o, esses dados deveriam ser salvos em banco de dados e exibidos no hist√≥rico do projeto, aqui estamos apenas simulando.)*

## 4. Biblioteca Inteligente de Assets com Busca e Tagging

Esta funcionalidade oferece uma biblioteca para gerenciar arquivos de m√≠dia (v√≠deos, imagens, √°udios) com organiza√ß√£o por tags e busca de arquivos. O usu√°rio pode fazer **upload** de arquivos, **adicionar tags** manualmente, e **buscar** por nome ou tag. Implementamos um **store Zustand** para gerenciar a lista de assets e suas tags, e um **componente de biblioteca** que exibe os assets e fornece recursos de upload e busca.

> **Nota:** A "intelig√™ncia" aqui fica como sugest√£o para melhorias futuras - por exemplo, integrar com IA para tagueamento autom√°tico (ex.: analisar imagem/v√≠deo e sugerir tags relevantes). Inclu√≠mos um coment√°rio no c√≥digo indicando essa evolu√ß√£o.

### Store: `store/useAssetsStore.ts`

Gerencia a lista de assets (cada asset tem id, nome, tipo e tags) e fornece a√ß√µes para adicionar um novo asset (a partir de um arquivo selecionado pelo usu√°rio), definir tags e buscar. Por simplicidade, os arquivos enviados n√£o s√£o realmente enviados a um servidor; o store apenas armazena localmente um URL de refer√™ncia (utilizando URL.createObjectURL para visualiza√ß√£o). Em produ√ß√£o, voc√™ faria upload para um servidor ou servi√ßo de storage e armazenaria a URL real.

```tsx
// store/useAssetsStore.ts
import { create } from 'zustand';

export type AssetType = 'image' | 'video' | 'audio';
export interface Asset {
  id: string;
  name: string;
  type: AssetType;
  url: string;
  tags: string[];
}

interface AssetsState {
  assets: Asset[];
  searchQuery: string;
  addAsset: (file: File, tags?: string[]) => void;
  setSearchQuery: (query: string) => void;
}

export const useAssetsStore = create<AssetsState>((set) => ({
  assets: [],
  searchQuery: '',
  addAsset: (file, tags = []) => {
    const id = Date.now().toString();
    // Determina tipo do asset pelo tipo MIME do arquivo
    let type: AssetType = 'image';
    if (file.type.startsWith('video')) type = 'video';
    else if (file.type.startsWith('audio')) type = 'audio';
    // Cria URL local para visualiza√ß√£o (n√£o persistente)
    const url = URL.createObjectURL(file);
    const newAsset: Asset = {
      id,
      name: file.name,
      type,
      url,
      tags
    };
    set((state) => ({ assets: [...state.assets, newAsset] }));
    // FUTURO: Poder√≠amos integrar um servi√ßo de IA aqui para analisar o arquivo e gerar tags autom√°ticas.
  },
  setSearchQuery: (query) => set({ searchQuery: query })
}));
```

### Componente: `app/events/[eventId]/assets/page.tsx`  (P√°gina de biblioteca de assets para um evento)

Este componente representa a p√°gina/biblioteca de assets. Nele h√° um campo de busca, um bot√£o/input de upload e a listagem de arquivos carregados. A listagem pode ser exibida em grade ou lista; aqui usamos uma simples lista com nome do arquivo, tipo, preview (se for imagem/v√≠deo) e tags. H√° tamb√©m a funcionalidade de filtrar a lista conforme a busca (por nome ou tags).

```tsx
// app/events/[eventId]/assets/page.tsx
'use client';
import { useState } from 'react';
import { useAssetsStore } from '@/store/useAssetsStore';

export default function AssetLibraryPage() {
  const { assets, searchQuery, addAsset, setSearchQuery } = useAssetsStore();
  const [tagInput, setTagInput] = useState(''); // tags fornecidas no upload

  const filteredAssets = assets.filter(asset => {
    const q = searchQuery.toLowerCase();
    return asset.name.toLowerCase().includes(q) || asset.tags.some(tag => tag.toLowerCase().includes(q));
  });

  const handleUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files;
    if (!files || files.length === 0) return;
    for (const file of files) {
      // Processa tags escritas (separadas por v√≠rgula ou espa√ßo)
      const tags = tagInput.split(/[,\s]+/).filter(Boolean);
      addAsset(file, tags);
    }
    // Limpa campos ap√≥s upload
    e.target.value = '';
    setTagInput('');
  };

  return (
    <div className="p-4">
      <h2 className="text-xl font-bold mb-4 text-neutral-100">Biblioteca de Assets</h2>
      {/* Barra de ferramentas: busca e upload */}
      <div className="flex items-center gap-4 mb-4">
        <input
          type="text"
          placeholder="Buscar por nome ou tag..."
          value={searchQuery}
          onChange={(e) => setSearchQuery(e.target.value)}
          className="px-3 py-1 rounded bg-neutral-700 text-white flex-1"
        />
        <input
          type="text"
          placeholder="Tags (opcional)"
          value={tagInput}
          onChange={(e) => setTagInput(e.target.value)}
          className="px-3 py-1 rounded bg-neutral-700 text-white"
        />
        <label className="px-4 py-2 bg-teal-600 rounded cursor-pointer hover:bg-teal-700">
          Upload
          <input type="file" multiple className="hidden" onChange={handleUpload} />
        </label>
      </div>
      {/* Lista de assets filtrados */}
      <div>
        {filteredAssets.map(asset => (
          <div key={asset.id} className="flex items-center gap-4 p-2 mb-2 border border-neutral-700 rounded">
            {/* Preview pequeno se imagem ou video */}
            {asset.type === 'image' ? (
              <img src={asset.url} alt={asset.name} className="w-16 h-16 object-cover rounded" />
            ) : asset.type === 'video' ? (
              <video src={asset.url} className="w-16 h-16 rounded" controls={false} />
            ) : (
              <div className="w-16 h-16 flex items-center justify-center bg-neutral-700 text-white">
                üéµ
              </div>
            )}
            {/* Nome e tags */}
            <div className="flex-1">
              <p className="text-neutral-100">{asset.name}</p>
              <p className="text-sm text-neutral-400">Tags: {asset.tags.join(', ') || '‚Äî'}</p>
            </div>
          </div>
        ))}
        {filteredAssets.length === 0 && (
          <p className="text-neutral-400">Nenhum asset encontrado para a busca "{searchQuery}".</p>
        )}
      </div>
    </div>
  );
}
```

**Integra√ß√£o e Teste:** Para verificar a biblioteca de assets:

1. Acesse a p√°gina de **Assets** do evento (ex: `/events/[eventId]/assets`). A interface exibir√° a lista de assets (inicialmente vazia), campo de busca e op√ß√£o de upload.
2. Clique no bot√£o **Upload** e selecione um ou mais arquivos (imagem, v√≠deo ou √°udio) do seu computador. Se desejar, antes de clicar em *Upload*, digite tags no campo "Tags (opcional)" (separadas por v√≠rgula ou espa√ßo) para serem associadas aos arquivos.
3. Ap√≥s selecionar os arquivos, eles aparecer√£o na lista, mostrando nome, tipo (com pr√©-visualiza√ß√£o se imagem/v√≠deo) e as tags atribu√≠das.
4. Utilize o campo **Buscar** para filtrar os assets por nome ou tag. Por exemplo, digite uma parte do nome do arquivo ou uma tag adicionada e confirme que apenas os assets correspondentes s√£o mostrados.
5. *(Lembre-se: os arquivos e tags est√£o armazenados apenas em mem√≥ria; ao recarregar a p√°gina eles ser√£o perdidos. Integra√ß√µes futuras envolveriam upload a um servidor e persist√™ncia dos metadados em banco.)*

## 5. Relat√≥rios de Performance por Evento (Dashboards Visuais)

Por fim, implementamos relat√≥rios b√°sicos de performance para cada evento, exibindo m√©tricas como **tempo m√©dio de aprova√ß√£o**, **tarefas conclu√≠das** e **coment√°rios resolvidos**, com visualiza√ß√£o atrav√©s de gr√°ficos simples. Usamos a biblioteca **Recharts** para plotar gr√°ficos (√© preciso instalar: `npm install recharts`). Os dados s√£o obtidos do estado (Zustand) dos projetos e coment√°rios.

### Componente: `components/widgets/EventPerformance.tsx`

Este componente obt√©m as m√©tricas do evento atual (por exemplo, via `useProjectsStore` que cont√©m projetos, coment√°rios e status) e renderiza gr√°ficos mostrando o percentual de tarefas conclu√≠das e coment√°rios resolvidos, bem como o tempo m√©dio de aprova√ß√£o. Utilizamos dois gr√°ficos de pizza (PieChart do Recharts) para ilustrar propor√ß√µes de tarefas e coment√°rios conclu√≠dos. Cores e estilos seguem o tema (usando cores compat√≠veis com o tema Dracula).

```tsx
// components/widgets/EventPerformance.tsx
'use client';
import { PieChart, Pie, Cell, Tooltip } from 'recharts';
import { useProjectsStore } from '@/store/useProjectsStore';  // store existente de projetos/coment√°rios

const COLORS_TASKS = ['#10B981', '#4B5563'];    // verde para feitas, cinza para pendentes
const COLORS_COMMENTS = ['#3B82F6', '#4B5563']; // azul para resolvidos, cinza para pendentes

export default function EventPerformance() {
  const currentProject = useProjectsStore((state) => state.currentProject);
  if (!currentProject) return null;
  // Calcula m√©tricas
  const tasksTotal = currentProject.tasks?.length ?? 0;
  const tasksCompleted = currentProject.tasks?.filter((t: any) => t.completed).length ?? 0;
  const commentsTotal = currentProject.comments?.length ?? 0;
  const commentsResolved = currentProject.comments?.filter((c: any) => c.resolved).length ?? 0;
  // Tempo m√©dio de aprova√ß√£o (dias) - diferen√ßa entre cria√ß√£o e aprova√ß√£o (se aprovado)
  let avgApprovalTimeDays = 0;
  if (currentProject.createdAt && currentProject.approvedAt) {
    const diffMs = new Date(currentProject.approvedAt).getTime() - new Date(currentProject.createdAt).getTime();
    avgApprovalTimeDays = diffMs / (1000 * 60 * 60 * 24);
  }
  // Dados para gr√°ficos
  const taskData = [
    { name: 'Conclu√≠das', value: tasksCompleted },
    { name: 'Pendentes', value: Math.max(0, tasksTotal - tasksCompleted) }
  ];
  const commentData = [
    { name: 'Resolvidos', value: commentsResolved },
    { name: 'Pendentes', value: Math.max(0, commentsTotal - commentsResolved) }
  ];

  return (
    <div className="p-4 bg-neutral-800 rounded">
      <h3 className="text-lg text-neutral-100 font-bold mb-2">Relat√≥rio de Performance</h3>
      <div className="text-neutral-100 mb-4">
        <p>Tempo m√©dio para aprova√ß√£o: <strong>{avgApprovalTimeDays.toFixed(1)}</strong> dias</p>
        <p>Tarefas conclu√≠das: <strong>{tasksCompleted}</strong> de <strong>{tasksTotal}</strong></p>
        <p>Coment√°rios resolvidos: <strong>{commentsResolved}</strong> de <strong>{commentsTotal}</strong></p>
      </div>
      <div className="flex gap-8 justify-start items-center">
        {/* Gr√°fico de Pizza - Tarefas */}
        <div>
          <PieChart width={120} height={120}>
            <Pie data={taskData} dataKey="value" nameKey="name" cx="50%" cy="50%" outerRadius={50} innerRadius={30} label>
              {taskData.map((entry, index) => (
                <Cell key={`cell-task-${index}`} fill={COLORS_TASKS[index % COLORS_TASKS.length]} />
              ))}
            </Pie>
            <Tooltip />
          </PieChart>
          <p className="text-center text-xs text-neutral-200">Tarefas</p>
        </div>
        {/* Gr√°fico de Pizza - Coment√°rios */}
        <div>
          <PieChart width={120} height={120}>
            <Pie data={commentData} dataKey="value" nameKey="name" cx="50%" cy="50%" outerRadius={50} innerRadius={30} label>
              {commentData.map((entry, index) => (
                <Cell key={`cell-comm-${index}`} fill={COLORS_COMMENTS[index % COLORS_COMMENTS.length]} />
              ))}
            </Pie>
            <Tooltip />
          </PieChart>
          <p className="text-center text-xs text-neutral-200">Coment√°rios</p>
        </div>
      </div>
    </div>
  );
}
```

**Integra√ß√£o e Teste:** Para adicionar o dashboard de performance:

1. Instale a biblioteca **Recharts** no projeto, caso ainda n√£o esteja presente: `npm install recharts`.

2. Importe e inclua o componente **`<EventPerformance />`** na p√°gina do evento (por exemplo, em uma se√ß√£o "Relat√≥rios" na p√°gina de detalhes do evento). Certifique-se de carreg√°-lo no cliente (pode usar import din√¢mico com `ssr: false` conforme exemplificado abaixo) j√° que gr√°ficos dependem do DOM:

   ```tsx
   import dynamic from 'next/dynamic';
   const EventPerformance = dynamic(() => import('@/components/widgets/EventPerformance'), { ssr: false });
   ...
   // No JSX da p√°gina do evento:
   <EventPerformance />
   ```

3. Navegue at√© a p√°gina de um evento que possua algumas tarefas e coment√°rios no estado. O componente exibir√°:

   * O tempo m√©dio para aprova√ß√£o (diferen√ßa entre cria√ß√£o e aprova√ß√£o do evento, se dispon√≠vel).
   * Quantidade de tarefas conclu√≠das vs. totais.
   * Quantidade de coment√°rios resolvidos vs. totais.
   * Dois gr√°ficos de pizza mostrando a porcentagem de tarefas conclu√≠das e de coment√°rios resolvidos.

4. Verifique se os n√∫meros e gr√°ficos correspondem aos dados do evento. Por exemplo, se marcar uma tarefa como conclu√≠da ou um coment√°rio como resolvido (no estado do projeto via DevTools ou simula√ß√£o), o gr√°fico deve ser atualizado refletindo a mudan√ßa.

5. Se o evento n√£o tiver sido aprovado ainda (sem `approvedAt`), o tempo m√©dio de aprova√ß√£o exibido ser√° 0.0 dias (podendo ser adaptado futuramente para n√£o exibir nada nesse caso, se desejado).

---

**Conclus√£o:** Os c√≥digos acima adicionam as funcionalidades solicitadas de forma modular, seguindo o padr√£o do projeto. Lembre-se de ajustar as importa√ß√µes e caminhos de acordo com a estrutura do seu projeto (por exemplo, certificar-se de que os paths `@/store/...` e `@/components/...` est√£o corretos no seu `tsconfig.json`). Ap√≥s colar os arquivos nos diret√≥rios correspondentes (`store`, `components/widgets`, `features` ou `app/events/[eventId]` conforme indicado), execute o projeto e teste cada funcionalidade seguindo as orienta√ß√µes fornecidas em cada se√ß√£o. Ajustes de estilo (Tailwind/tema) podem ser feitos para harmonizar com o restante da aplica√ß√£o.
